import heapq

def solution(N, road, K):
    answer = 0
    
    # 다익스트라 알고리즘을 사용해야하네
    #     왜? 다익스트라 알고리즘은 시작점에서 다른 모든 정점까지의 최단 경로를 구할 수 있기 때문이네
    
    # 다익스트라 알고리즘이 bfs랑 뭐가 다르지?
    #     : 다익스트라 알고리즘은 가중치가 있는 그래프에서 최단 경로를 구하는    알고리즘이네
    #     : bfs는 가중치가 없는 상황에서 최단 거리를 구하는 문제에서 사용하네
    
    # 다익스트라 알고리즘을 쓸 수 있는 문제 조건이 뭐지?
    #     : 가중치가 있어야 하네
    #     : 음수 가중치가 없어야 하네

    # 다익스트라 알고리즘의 핵심이 뭘까?
    #     : 각 단계에서 현재까지 알려진 최단거리노드를 선택하고, 그 노드의 이웃 노드들의 거리를 업데이트 한다.
    #     : 우선순위 큐를 사용하는 것이네 


    # 다익스트라 알고리즘이 어떻게 생겼더라?
    #     1. 그래프 정보 받아서, 그래프 정보 저장하기
    #     2. 시작점에서 각 정점까지의 거리를 저장할 최단거리 배열을 만들고, inf로 초기화하기
    #     3. 시작점을 큐에 넣고, 시작점 까지의 최단거리를 0으로 초기화하기
    #     4. while q: 돌면서 -> 큐에서 노드를 꺼내서, -> 유의미한지 판단하고 -> 그 노드에서 갈 수 있는 노드들을 순회하면서, 최단거리 테이블 갱신하기&큐에 넣기


    graph = [[] for _ in range(N+1)]
    for _ in range(len(road)):
        a,b,c = road[_]
        # 양방향 그래프
        graph[a].append((b,c)) # a에서 b까지 가는 가중치는 c
        graph[b].append((a,c)) # b에서 a까지 가는 가중치는 c 

    print(graph)

    dist = [int(1e9)]*(N+1) # 1번 마을에서 1~N 마을까지 가는데 걸리는 최단 거리를 저장할 배열
    dist[1] = 0 # 1번 마을에서 1번 마을까지는 0시간 걸리지용

    q = [] 
    heapq.heappush(q, (0,1)) # (거리, 노드) # heapq가 '거리'를 기준으로 min-heap으로 작동한다.

    # 1에서부터 갈 수 있는 노드 방문해서, 그 노드까지 걸리는 dist 갱신
    while q:
        cur_dist, node = heapq.heappop(q) # 가장 거리가 작은 노드를 꺼내기

        # 1. cur_dist가 유의미한지 확인
        if cur_dist > dist[node]: # 지금 방문하려는 노드까지의 거리가 이전에 계산된 최단거리보다 크다면, 이건 최단경로가 아니다. 그니까 고려하지 않고 continue !
            continue # while문의 처음으로 돌아가서 다음 노드를 꺼내기

        # 2. 지금 노드에서 갈 수 있는 노드들을 순회하면서, dist 갱신
        for next_node, next_dist in graph[node]:
            # 3. 갱신된 dist가 최단거리테이블에 있는 값보다 작다면, 최단거리테이블 갱신
            cost = cur_dist + next_dist
            if cost < dist[next_node]: # next_dist에 현재 dist 값을 더한 것이, 현재 최단거리 테이블[next_node]보다 작다면, 최단거리테이블 갱신필요
                # 4. 최단거리테이블 갱신
                dist[next_node] = cost
                # 5. 그리고 그 노드를 큐에 넣기 for 이어서 가능한 경로들을 가기 위해
                heapq.heappush(q, (cost, next_node))
    
    # 그러면 지금 dist가 가지고 있는 것은 뭐지?
    # : 1번 마을에서 각 마을까지 가는 최단거리를 가지고 있네

    # 출력값 구하기
    for item in dist:
        if item <= K:
            answer += 1

    return answer

if __name__=="__main__":
    print(solution(5, [[1,2,1],[2,3,3],[5,2,2],[1,4,2],[5,3,1],[5,4,2]], 3)) # 4
    print(solution(6, [[1,2,1],[1,3,2],[2,3,2],[3,4,3],[3,5,2],[3,5,3],[5,6,1]], 4)) # 4
